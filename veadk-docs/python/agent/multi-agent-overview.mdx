---
title: "概述"
---


多 Agent 系统架构通常有两种架构方式: **本地多 Agent 架构** 和 **A2A 架构**

- **本地多 Agent 架构**：这类 Agent 与主 Agent 在同一个应用进程中。它们更像内部模块或库，用于将代码组织为逻辑、可复用的组件。主 Agent 与 Local Sub-Agents 之间的通信直接发生在内存中，无需网络开销，因此速度非常快。
- **A2A 架构**：这类 Agent 以独立服务形式运行，通过网络进行通信。A2A 为此类通信定义了标准协议。

## 选择合适的 Agent 架构

并不是所有场景都适合使用 A2A，需要您参考以下建议，结合实际使用场景和需求作出合适选择，下面是一些适用于 A2A 的场景：

| 场景名称 | 说明 |
| - | - |
| **集成第三方服务** | 需要交互的 Agent 是一个独立的、可单独运行的第三方服务(例如需要从外部金融数据服务获取实时交易信息) |
| **微服务架构** | 不同的 Agent 由不同的团队或组织维护, A2A 用于些服务跨网络边界相互通信 |
| **跨语言通信** | 要连接使用不同编程语言或 Agent 框架实现的 Agent, A2A 提供了标准化的通信层 |
| **严格的 API 契约** | 为了保证兼容性与稳定性，需要为 Agent 之间的交互制定严格契约 |

下面是一些不适用于 A2A 的场景：

| 场景名称 | 说明 |
| - | - |
| **内部代码组织** | 您在单个 Agent 内将复杂任务拆分为更小、可管理的函数或模块，这类场景出于性能与简洁考虑，更适合作为本地子 |
| **性能关键的内部操作** | 某个 Sub Agent 负责与主 Agent 执行紧密耦合的高频、低延迟操作，这类场景由于需要低延迟响应，更适合作为本地Local Sub-Agents |
| **共享内存或上下文** | 当 Sub Agent 需要直接访问主 Agent 的内部状态或共享内存以提高效率时，A2A 的网络开销与序列化/反序列化会适得其反 |
| **简单的辅助函数** | 对于无需独立部署或复杂状态管理的小型复用逻辑，直接在同一 Agent 中编写函数或类，通常比拆分为独立的 A2A Agent 更合适 |